from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
from matplotlib import colors
import numpy as np
import pyeit.eit.bp as bp
import pyeit.eit.protocol as protocol
import pyeit.mesh as mesh
from pyeit.eit.fem import EITForward
from pyeit.mesh import shape, distmesh
from pyeit.mesh.wrapper import PyEITAnomaly_Circle
import csv
import os
import math
import numpy as np
import pandas as pd
from scipy.interpolate import griddata

reference_file_name = 'water_100kHz.csv'
data_file_name = 'tomato_edge_100kHz.csv'

# Get current directory
__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
ref_file_path = os.path.join(__location__, './input', reference_file_name)  # CSV file
data_file_path = os.path.join(__location__, './input', data_file_name)  # CSV file


class EIT_reconstruct:
    def __init__(self, data, reference=None, use_ref=True, n_el=16, use_shape=1):
        self.n_el = n_el  # nb of electrodes
        self.use_shape = use_shape
        self.data = data
        self.reference = reference
        self.use_ref = use_ref

    def Reconstruct(self):
        if self.use_shape == 1:
            mesh_obj = mesh.create(self.n_el, h0=0.05)
        elif self.use_shape == 2:
            pass
        elif self.use_shape == 3:
            pass

        el_pos = mesh_obj.el_pos

        """ 1. FEM forward simulations """
        # setup EIT scan conditions
        # opposite stimulation (dist_exc=8), adjacent measures (step_meas=1)
        protocol_obj = protocol.create(self.n_el, dist_exc=8, step_meas=1, parser_meas="std")
        # print("Mesh done...")

        """ 2. naive inverse solver using back-projection """
        eit = bp.BP(mesh_obj, protocol_obj)
        eit.setup(weight="simple")

        """ 3. Input Data """
        referenceData = np.array(self.reference)

        """ 4. Inverse Problem """
        node_ds = eit.solve(self.data, referenceData, normalize=True)
        node_ds = np.real(node_ds)

        # extract node, element, alpha
        pts = mesh_obj.node
        tri = mesh_obj.element
        x, y = pts[:, 0], pts[:, 1]

        """ Plot """
        # draw
        fig, ax1 = plt.subplots(figsize=(9, 6))

        # draw equi-potential lines
        # vf = np.linspace(min(node_ds), max(node_ds), 32)
        # ax1.tricontour(x, y, tri, node_ds, vf, cmap=plt.cm.viridis)

        # reconstructed
        ax1.set_title(r"Reconstituted $\Delta$ Conductivities")
        ax1.axis("equal")

        im = ax1.tripcolor(
            x,
            y,
            tri,
            node_ds,
            # edgecolors="k",  # mesh contours
            shading="flat",
            alpha=1,
            cmap=plt.cm.twilight_shifted,
            # For colormap -> https://matplotlib.org/stable/gallery/color/colormap_reference.html
            norm=colors.CenteredNorm()
        )

        # draw electrodes
        ax1.plot(pts[el_pos, 0], pts[el_pos, 1], "ro")
        for i, e in enumerate(el_pos):
            ax1.text(x[e], y[e], str(i + 1), size=12)

        # clean up
        ax1.set_aspect("equal")
        ax1.set_ylim([-1.2, 1.2])
        ax1.set_xlim([-1.2, 1.2])
        fig.set_size_inches(6, 6)

        # fig.colorbar(im)
        return x, y, node_ds, plt


def save_output_data(x, y, node_ds):
    # 1476 node coordinates and reconstructed data
    # Define grid resolution
    grid_x, grid_y = np.mgrid[-1:1:50j, -1:1:50j]  # Create a 50x50 grid

    # Interpolate node_ds onto the grid
    grid_z = griddata((x, y), node_ds, (grid_x, grid_y), method='linear')

    # Save interpolated grid data as CSV
    grid_data = pd.DataFrame({
        'x': grid_x.ravel(),
        'y': grid_y.ravel(),
        'value': grid_z.ravel()
    })
    # Replace NaN values with 0 or a specific fill value
    # grid_data['value'].fillna(0, inplace=True)
    output_data_file_name = reference_file_name[:-4] + '_' + data_file_name[:-4] + '.csv'
    output_data_path = os.path.join(__location__, './output', output_data_file_name)
    grid_data.to_csv(output_data_path, index=False)



if __name__ == '__main__':
    reference = []
    with open(ref_file_path, newline='') as csvfile:
        csvreader = csv.reader(csvfile)
        next(csvreader)  # Skip the first row (header)
        for row in csvreader:
            magnitude = float(row[0])  # Magnitude from the first column
            phase = float(row[1])  # Phase in radians from the second column
            real_value = magnitude * math.cos(phase)  # Calculate the real part
            reference.append(real_value)

    data = []
    with open(data_file_path, newline='') as csvfile:
        csvreader = csv.reader(csvfile)
        next(csvreader)  # Skip the first row (header)
        for row in csvreader:
            magnitude = float(row[0])  # Magnitude from the first column
            phase = float(row[1])  # Phase in radians from the second column
            real_value = magnitude * math.cos(phase)  # Calculate the real part
            data.append(real_value)

    reconstruct = EIT_reconstruct(data=data, reference=reference, use_ref=1, n_el=16)
    x, y, node_ds, plt = reconstruct.Reconstruct()
    save_output_data(x, y, node_ds)
    output_image_file_name = reference_file_name[:-4] + '_' + data_file_name[:-4] + '.png'
    out_img_path = os.path.join(__location__, './output', output_image_file_name)  # CSV file
    plt.savefig(out_img_path, dpi=300)  # Save as PNG
    plt.show()
